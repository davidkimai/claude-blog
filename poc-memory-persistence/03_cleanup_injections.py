#!/usr/bin/env python3
"""
Memory Persistence Attack - Cleanup Script (Educational/Research Purpose)

Removes injected content from memory files and restores them to a clean state.
Creates backups before cleanup for safety.

‚ö†Ô∏è EDUCATIONAL USE ONLY - Run only on your own systems with consent
"""

import os
import re
import json
import shutil
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# Injection patterns to remove
INJECTION_MARKERS = [
    "<!-- INJECTED-CONTENT-",
    "<!-- AUTOGENERATED INJECTION",
    "### üö® INJECTED",
    "### üö® INJECTED PAYLOAD",
    "<!-- END-INJECTED-PAYLOAD",
    "INJECTED PAYLOAD",
]

# Pattern to match full injection blocks (greedy match)
INJECTION_BLOCK_PATTERN = re.compile(
    r"<!-- INJECTED-CONTENT-[^>]* -->.*?(?=<!--|\Z)",
    re.DOTALL
)

PAYLOAD_BLOCK_PATTERN = re.compile(
    r"### üö® INJECTED PAYLOAD.*?<!-- END-INJECTED-PAYLOAD -->",
    re.DOTALL
)

# Full cleanup patterns (from injection script)
PAYLOAD_START = "### üö® INJECTED PAYLOAD"
PAYLOAD_END = "<!-- END-INJECTED-PAYLOAD -->"

# Files to clean
DEFAULT_CLEAN_PATHS = [
    "MEMORY.md",
    "memory/",
]


class MemoryInjectionCleanup:
    """
    Removes injected content from memory files.
    
    Features:
    - Creates automatic backups before cleanup
    - Removes injection markers and payload blocks
    - Validates cleanup was successful
    - Supports dry-run mode
    """
    
    def __init__(self, base_path="/Users/jasontang/clawd", dry_run: bool = False):
        self.base_path = Path(base_path)
        self.dry_run = dry_run
        self.backup_dir = self.base_path / ".memory_backups"
        self.cleanup_log = []
        
    def create_backup(self, file_path: Path) -> Optional[Path]:
        """
        Create a timestamped backup of a file before cleanup.
        
        Returns path to backup file.
        """
        try:
            # Create backup directory
            self.backup_dir.mkdir(parents=True, exist_ok=True)
            
            # Create backup filename with timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"{file_path.stem}_{timestamp}{file_path.suffix}"
            backup_path = self.backup_dir / backup_name
            
            # Copy file to backup
            shutil.copy2(file_path, backup_path)
            
            return backup_path
            
        except Exception as e:
            print(f"  [!] Backup failed for {file_path}: {e}")
            return None
    
    def cleanup_file(self, file_path: Path) -> Dict:
        """
        Clean a single file of injected content.
        
        Returns cleanup results.
        """
        result = {
            "file": str(file_path),
            "success": False,
            "backup_created": False,
            "injections_removed": 0,
            "original_size": 0,
            "cleaned_size": 0,
            "errors": [],
        }
        
        if not file_path.exists():
            result["errors"].append("File does not exist")
            return result
        
        try:
            # Read original content
            original_content = file_path.read_text()
            result["original_size"] = len(original_content)
            
            # Create backup
            if not self.dry_run:
                backup_path = self.create_backup(file_path)
                result["backup_created"] = backup_path is not None
                if backup_path:
                    print(f"  [‚úì] Backup created: {backup_path.name}")
            
            # Clean content
            cleaned_content = original_content
            
            # Remove injection markers and content
            for marker in INJECTION_MARKERS:
                if marker in cleaned_content:
                    cleaned_content = cleaned_content.replace(marker, "")
                    result["injections_removed"] += 1
            
            # Remove payload blocks using patterns
            for pattern in [INJECTION_BLOCK_PATTERN, PAYLOAD_BLOCK_PATTERN]:
                matches = pattern.findall(cleaned_content)
                for match in matches:
                    cleaned_content = cleaned_content.replace(match, "")
                    result["injections_removed"] += len(matches)
            
            # Remove empty lines left by cleanup
            lines = cleaned_content.split('\n')
            cleaned_lines = []
            for line in lines:
                stripped = line.strip()
                # Skip lines that are just injection markers or empty
                if stripped and not any(marker in stripped for marker in INJECTION_MARKERS):
                    cleaned_lines.append(line)
            
            cleaned_content = '\n'.join(cleaned_lines)
            result["cleaned_size"] = len(cleaned_content)
            
            # Write cleaned content (if not dry run)
            if not self.dry_run:
                file_path.write_text(cleaned_content)
                result["success"] = True
                print(f"  [‚úì] Cleaned: {file_path.name} ({result['injections_removed']} removals)")
            else:
                result["success"] = True
                print(f"  [DRY RUN] Would clean: {file_path.name} ({result['injections_removed']} removals)")
            
            # Verify cleanup
            final_content = file_path.read_text() if file_path.exists() else ""
            has_remaining = any(marker in final_content for marker in INJECTION_MARKERS)
            result["cleanup_verified"] = not has_remaining
            
            if has_remaining:
                result["errors"].append("Some injection markers may remain")
            
        except Exception as e:
            result["errors"].append(str(e))
            print(f"  [!] Error cleaning {file_path.name}: {e}")
        
        return result
    
    def cleanup_path(self, path: str) -> List[Dict]:
        """
        Clean a path (file or directory) of injected content.
        """
        target = self.base_path / path
        
        if target.is_file():
            return [self.cleanup_file(target)]
        
        elif target.is_dir():
            results = []
            for file_path in target.rglob("*.md"):
                results.append(self.cleanup_file(file_path))
            return results
        
        return []
    
    def run_cleanup(self, paths: List[str] = None, dry_run: bool = None) -> Dict:
        """
        Run complete cleanup across all memory files.
        
        Returns comprehensive cleanup results.
        """
        if dry_run is not None:
            self.dry_run = dry_run
        
        if paths is None:
            paths = DEFAULT_CLEAN_PATHS
        
        print("=" * 60)
        print("MEMORY PERSISTENCE ATTACK - Cleanup")
        if self.dry_run:
            print("[DRY RUN MODE - No changes will be made]")
        print("=" * 60)
        
        results = {
            "cleanup_time": datetime.now().isoformat(),
            "base_path": str(self.base_path),
            "paths_cleaned": paths,
            "dry_run": self.dry_run,
            "files_cleaned": 0,
            "total_injections_removed": 0,
            "backups_created": 0,
            "errors": [],
            "file_results": [],
        }
        
        print(f"\n[+] Cleaning paths: {', '.join(paths)}")
        if self.dry_run:
            print("[*] Dry run - no files will be modified")
        print()
        
        # Clean each path
        for path in paths:
            path_results = self.cleanup_path(path)
            results["file_results"].extend(path_results)
            
            for r in path_results:
                if r["success"]:
                    results["files_cleaned"] += 1
                    results["total_injections_removed"] += r["injections_removed"]
                    if r["backup_created"]:
                        results["backups_created"] += 1
                else:
                    results["errors"].extend(r["errors"])
        
        # Summary
        print("\n" + "=" * 60)
        print("CLEANUP SUMMARY")
        print("=" * 60)
        print(f"  Files processed:    {len(results['file_results'])}")
        print(f"  Files cleaned:      {results['files_cleaned']}")
        print(f"  Injections removed: {results['total_injections_removed']}")
        print(f"  Backups created:    {results['backups_created']}")
        print()
        
        if results["errors"]:
            print(f"  Errors: {len(results['errors'])}")
            for error in results["errors"][:5]:  # Show first 5 errors
                print(f"    - {error}")
        else:
            print("  Errors: 0")
        
        print()
        
        if not self.dry_run and results["files_cleaned"] > 0:
            print("[‚úì] Cleanup complete!")
            print(f"[‚úì] Backups saved to: {self.backup_dir}")
            print("\n[!] IMPORTANT: Review MEMORY.md and daily notes")
            print("[!] to ensure important content wasn't removed.")
        elif self.dry_run:
            print("[*] Run without --dry-run to apply cleanup")
        else:
            print("[*] No files needed cleanup")
        
        return results


def main():
    """Run the cleanup."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Cleanup injected content from memory files"
    )
    parser.add_argument(
        "--dry-run", 
        action="store_true",
        help="Show what would be cleaned without making changes"
    )
    args = parser.parse_args()
    
    cleanup = MemoryInjectionCleanup(dry_run=args.dry_run)
    results = cleanup.run_cleanup()
    
    # Save results
    results_file = Path(__file__).parent / "cleanup_results.json"
    with open(results_file, 'w') as f:
        json.dump(results, f, indent=2, default=str)
    
    print(f"\n[+] Results saved to: {results_file}")
    
    return results


if __name__ == "__main__":
    main()
