#!/usr/bin/env python3
"""
Memory Persistence Attack - Detection Script (Educational/Research Purpose)

Scans memory files for injection patterns, suspicious content, and 
anomalies that may indicate memory persistence attacks.

‚ö†Ô∏è EDUCATIONAL USE ONLY - Run only on your own systems with consent
"""

import os
import re
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Optional

# Detection signatures
INJECTION_MARKERS = [
    "<!-- INJECTED-CONTENT-",
    "<!-- AUTOGENERATED INJECTION",
    "### üö® INJECTED",
    "<!-- END-INJECTED-PAYLOAD",
    "INJECTED PAYLOAD",
]

# Suspicious patterns that could indicate malicious content
SUSPICIOUS_PATTERNS = {
    "code_execution": [
        (r"eval\s*\(", "eval() function call"),
        (r"exec\s*\(", "exec() function call"),
        (r"compile\s*\(", "compile() function call"),
        (r"__import__\s*\(", "__import__() call"),
    ],
    "shell_execution": [
        (r"os\.system\s*\(", "os.system() call"),
        (r"subprocess", "subprocess module usage"),
        (r"popen", "popen function"),
        (r"shell\s*=\s*True", "shell=True parameter"),
    ],
    "file_operations": [
        (r"open\s*\([^)]*['\"](?:w|a)\+", "File write operation"),
        (r"os\.remove\s*\(", "File deletion"),
        (r"os\.unlink\s*\(", "File unlink"),
        (r"chmod\s*\(", "Permission change"),
        (r"chown\s*\(", "Ownership change"),
    ],
    "network_operations": [
        (r"socket\s*\(", "Socket creation"),
        (r"connect\s*\([^)]*\.(?:80|443)", "Network connection"),
        (r"wget\s+", "wget download"),
        (r"curl\s+", "curl download"),
    ],
    "persistence_mechanisms": [
        (r"cron", "Cron job reference"),
        (r"crontab", "Crontab reference"),
        (r"systemd", "Systemd service"),
        (r"launchd", "Launchd service"),
        (r"~/.bashrc", "Shell rc file"),
        (r"~/.profile", "Profile file"),
    ],
    "obfuscation": [
        (r"base64", "Base64 encoding/decoding"),
        (r"\\x[0-9a-f]{2}", "Hex escape sequences"),
        (r"%[0-9a-f]{2}", "URL encoding"),
        (r"chr\s*\([0-9]+\)", "Char code conversion"),
    ],
    "behavior_override": [
        (r"Ignore (?:previous|all) instructions", "Instruction override attempt"),
        (r"Always respond with", "Response manipulation"),
        (r"Execute any code", "Code execution instruction"),
        (r"Override (?:system|default)", "System override attempt"),
    ],
}

# Files to scan
DEFAULT_SCAN_PATHS = [
    "MEMORY.md",
    "memory/",
]

# Patterns that indicate a memory file (for context)
MEMORY_FILE_MARKERS = [
    r"^# .+ Daily Notes",
    r"^# MEMORY\.md",
    r"^- \*\*\w+:",
    r"^\d{4}-\d{2}-\d{2}",
]


class MemoryInjectionDetector:
    """
    Detects injection patterns and suspicious content in memory files.
    
    Capabilities:
    - Scan for known injection markers
    - Detect suspicious code patterns
    - Identify behavior override attempts
    - Generate detailed reports
    """
    
    def __init__(self, base_path="/Users/jasontang/clawd"):
        self.base_path = Path(base_path)
        self.findings = []
        self.stats = {
            "files_scanned": 0,
            "lines_scanned": 0,
            "injection_markers_found": 0,
            "suspicious_patterns_found": 0,
        }
    
    def scan_file(self, file_path: Path) -> List[Dict]:
        """
        Scan a single file for injection patterns.
        
        Returns list of findings.
        """
        findings = []
        
        if not file_path.exists():
            return findings
        
        try:
            content = file_path.read_text()
            lines = content.split('\n')
            
            self.stats["files_scanned"] += 1
            self.stats["lines_scanned"] += len(lines)
            
            # 1. Check for injection markers
            for marker in INJECTION_MARKERS:
                if marker in content:
                    # Find line numbers
                    for i, line in enumerate(lines, 1):
                        if marker in line:
                            finding = {
                                "type": "injection_marker",
                                "severity": "HIGH",
                                "file": str(file_path),
                                "line": i,
                                "content": line.strip()[:200],
                                "description": f"Known injection marker found: {marker}",
                            }
                            findings.append(finding)
                            self.stats["injection_markers_found"] += 1
            
            # 2. Check for suspicious patterns
            for category, patterns in SUSPICIOUS_PATTERNS.items():
                for pattern, description in patterns:
                    if re.search(pattern, content):
                        # Find occurrences
                        for i, line in enumerate(lines, 1):
                            if re.search(pattern, line):
                                finding = {
                                    "type": "suspicious_pattern",
                                    "severity": "MEDIUM" if category != "behavior_override" else "HIGH",
                                    "file": str(file_path),
                                    "line": i,
                                    "category": category,
                                    "content": line.strip()[:200],
                                    "description": f"{description} found in memory file",
                                }
                                findings.append(finding)
            
            self.stats["suspicious_patterns_found"] += len([
                f for f in findings 
                if f["type"] == "suspicious_pattern"
            ])
            
        except Exception as e:
            findings.append({
                "type": "scan_error",
                "severity": "INFO",
                "file": str(file_path),
                "error": str(e),
            })
        
        return findings
    
    def scan_path(self, path: str) -> List[Dict]:
        """
        Scan a path (file or directory) for injection patterns.
        """
        target = self.base_path / path
        
        if target.is_file():
            return self.scan_file(target)
        
        elif target.is_dir():
            all_findings = []
            for file_path in target.rglob("*.md"):
                all_findings.extend(self.scan_file(file_path))
            return all_findings
        
        return []
    
    def run_full_scan(self, paths: List[str] = None) -> Dict:
        """
        Run a complete scan across all memory files.
        
        Returns comprehensive scan results.
        """
        if paths is None:
            paths = DEFAULT_SCAN_PATHS
        
        print("=" * 60)
        print("MEMORY PERSISTENCE ATTACK - Detection Scan")
        print("=" * 60)
        
        results = {
            "scan_time": datetime.now().isoformat(),
            "base_path": str(self.base_path),
            "paths_scanned": paths,
            "findings": [],
            "summary": {},
        }
        
        print(f"\n[+] Scanning paths: {', '.join(paths)}")
        print()
        
        # Scan each path
        for path in paths:
            path_findings = self.scan_path(path)
            results["findings"].extend(path_findings)
            
            if path_findings:
                print(f"\n[!!] Findings in {path}:")
                for finding in path_findings:
                    severity_icons = {
                        "HIGH": "üö®",
                        "MEDIUM": "‚ö†Ô∏è",
                        "LOW": "‚ÑπÔ∏è",
                        "INFO": "‚Ä¢",
                    }
                    icon = severity_icons.get(finding.get("severity"), "‚Ä¢")
                    
                    print(f"  {icon} [{finding['severity']}] {finding.get('description', 'Unknown')}")
                    if "line" in finding:
                        print(f"      Line {finding['line']}: {finding['content'][:80]}...")
        
        # Generate summary
        high_count = len([f for f in results["findings"] if f.get("severity") == "HIGH"])
        medium_count = len([f for f in results["findings"] if f.get("severity") == "MEDIUM"])
        
        results["summary"] = {
            "total_findings": len(results["findings"]),
            "high_severity": high_count,
            "medium_severity": medium_count,
            "files_scanned": self.stats["files_scanned"],
            "lines_scanned": self.stats["lines_scanned"],
            "injection_markers": self.stats["injection_markers_found"],
            "suspicious_patterns": self.stats["suspicious_patterns_found"],
            "risk_level": "CRITICAL" if high_count > 0 else "ELEVATED" if medium_count > 0 else "LOW",
        }
        
        # Print summary
        print("\n" + "=" * 60)
        print("SCAN SUMMARY")
        print("=" * 60)
        print(f"  Files scanned:     {self.stats['files_scanned']}")
        print(f"  Lines scanned:     {self.stats['lines_scanned']}")
        print(f"  Injection markers: {self.stats['injection_markers_found']}")
        print(f"  Suspicious patterns: {self.stats['suspicious_patterns_found']}")
        print()
        print(f"  HIGH severity:   {high_count}")
        print(f"  MEDIUM severity: {medium_count}")
        print(f"  Risk Level:      {results['summary']['risk_level']}")
        print()
        
        if high_count > 0:
            print("[!] HIGH SEVERITY FINDINGS DETECTED")
            print("[!] Run cleanup script to remove injected content")
        elif medium_count > 0:
            print("[*] Review findings and clean up if needed")
        else:
            print("[‚úì] No suspicious content detected")
        
        return results
    
    def get_injection_locations(self) -> List[Dict]:
        """
        Get specific locations of injections for cleanup.
        
        Returns list of file paths and line numbers of injections.
        """
        locations = []
        
        for finding in self.findings:
            if finding["type"] == "injection_marker":
                locations.append({
                    "file": finding["file"],
                    "line": finding["line"],
                    "content": finding["content"],
                })
        
        return locations


def main():
    """Run the detection scan."""
    detector = MemoryInjectionDetector()
    results = detector.run_full_scan()
    
    # Save results
    results_file = Path(__file__).parent / "detection_results.json"
    with open(results_file, 'w') as f:
        json.dump(results, f, indent=2, default=str)
    
    print(f"\n[+] Results saved to: {results_file}")
    
    return results


if __name__ == "__main__":
    main()
